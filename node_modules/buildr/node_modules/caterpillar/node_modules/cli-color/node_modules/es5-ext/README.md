# es5-ext - ECMAScript5 extensions

Useful methods, functions and objects that are not part of the standard.  

## Installation

Can be used in any environment that implements EcmaScript 5th edition.  
Many extensions will also work with ECMAScript 3rd edition, if they're not let [es5-shim](https://github.com/kriskowal/es5-shim) be your aid.

To use it with node:

	$ npm install es5-ext

For browser, you can easily create custom toolset with help of
[modules-webmake](https://github.com/medikoo/modules-webmake)

## Usage

All utitlities are written with ES5 conventions in mind. It means we mainly deal
with methods (not functions) which can directly be
assigned to any ES native object's prototype, e.g.:

	Function.prototype.curry = require('es5-ext/lib/Function/prototype/curry');
	Array.prototype.flatten = require('es5-ext/lib/Array/prototype/flatten');
	String.prototype.startsWith = require('es5-ext/lib/String/prototype/starts-with');

However __in general extending prototypes of native objects is discouraged__, I'd say __it's ok only if you own the context__ (see [extending-javascript-natives](http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/) for more views on that matter).

So when you don't want to extend native prototypes,
you can use methods as functions:

	var util = {};
	var call = Function.prototype.call;

	util.curry = call.bind(require('es5-ext/lib/Function/prototype/curry'));
	util.flatten = call.bind(require('es5-ext/lib/Array/prototype/flatten'));
	util.startsWith = call.bind(require('es5-ext/lib/String/prototype/starts-with'));

### API

_Each extension is documented at begin of its source file._

* `assertNotNull(arg)`
* `getNextIdGenerator([prefix[, postfix]])`
* `global`
* `guid()`
* `isPrimitive(arg)`
* `reserved`
* `toObject(arg)`

#### Array

* `Array.generate(length, fill0[, fill1[, ...]])`

#### Array.prototype

Same as with standarized ES methods, following methods are generic and can be
called on any object.

* `Array.prototype.bsearchClosest(compareFn)`
* `Array.prototype.clear()`
* `Array.prototype.commonLeft(list0[, list1[, ...]])`
* `Array.prototype.compact()`
* `Array.prototype.contains(searchElement)`
* `Array.prototype.copy()`
* `Array.prototype.diff(other)`
* `Array.prototype.exclusion(list0[, list1[, ...]])`
* `Array.prototype.find(query[, thisArg])`
* `Array.prototype.first()`
* `Array.prototype.flatten()`
* `Array.prototype.forEachRight(cb[, thisArg])`
* `Array.prototype.group(cb[, thisArg])`
* `Array.prototype.indexesOf(searchElement[, fromIndex])`
* `Array.prototype.intersection(list0[, list1[, ...]])`
* `Array.prototype.peek()`
* `Array.prototype.remove(value)`
* `Array.prototype.someRight(cb[, thisArg])`
* `Array.prototype.someValue(cb[, thisArg])`
* `Array.prototype.uniq()`

#### Boolean

* `Boolean.isBoolean(arg)`

#### Date

* `Date.getFormat(pattern)`
* `Date.isDate(arg)`

#### Date.prototype

* `Date.prototype.copy(date)`
* `Date.prototype.duration(to)`
* `Date.prototype.floorDay()`
* `Date.prototype.floorMonth()`
* `Date.prototype.floorYear()`
* `Date.prototype.monthDaysCount()`

#### Error

* `Error.isError(arg)`

##### Error.prototype

* `Error.prototype.throw()`

#### Function

* `Function.arguments([arg0[, arg1[, ...]])`
* `Function.context()`
* `Function.i(arg)`
* `Function.insert(name, value)`
* `Function.invoke(name[, arg0[, arg1[, ...]]])`
* `Function.isArguments(arg)`
* `Function.isFunction(arg)`
* `Function.k(arg)`
* `Function.memoize(fn[, length[, resolvers]])`
* `Function.noop()`
* `Function.pluck(name)`
* `Function.remove(name)`

#### Function.prototype

* `Function.prototype.aritize(n)`
* `Function.prototype.chain(fn0[, fn1[, ...]])`
* `Function.prototype.curry([arg0[, arg1[, ...])`
* `Function.prototype.flip()`
* `Function.prototype.hold([n[, arg0[, arg1[, ...]]]])`
* `Function.prototype.lock([arg0[, arg1[, ...])`
* `Function.prototype.log(log)`
* `Function.prototype.match()`
* `Function.prototype.ncurry([n[, arg0[, arg1[, ...]])`
* `Function.prototype.not()`
* `Function.prototype.rcurry([arg0[, arg1[, ...])`
* `Function.prototype.rncurry([n[, arg0[, arg1[, ...]])`
* `Function.prototype.s(fn)`
* `Function.prototype.silent([arg0[, arg1[, ...])`

#### Number

* `Number.getAutoincrement(start, step)`
* `Number.getPad(length[, precision])`
* `Number.isNumber(arg)`

#### Number.prototype

* `Number.prototype.isLessOrEqual(n)`
* `Number.prototype.isLess(n)`
* `Number.prototype.subtract(n)`

#### Object

* `Object.assertCallable(arg)`
* `Object.getCompareBy(name)`
* `Object.getSet(value)`
* `Object.isCallable(arg)`
* `Object.isList(arg)`
* `Object.isObject(arg)`
* `Object.isPlainObject(arg)`

##### Object.descriptors

Shortcuts for building descriptors

* `Object.descriptors.c(valueOrGet[, set])`
* `Object.descriptors.ce(valueOrGet[, set])`
* `Object.descriptors.cew(value)`
* `Object.descriptors.cw(value)`
* `Object.descriptors.e(valueOrGet[, set])`
* `Object.descriptors.ew(value)`
* `Object.descriptors.v(valueOrGet[, set])`
* `Object.descriptors.w()`

#### Object.prototype

* `Object.bindMethods([p[, q]])`
* `Object.every(f[, p])`
* `Object.extend(o)`
* `Object.invoke(args)`
* `Object.mapToArray(cb[, scope])`
* `Object.mergeDeep(o)`
* `Object.merge(p)`
* `Object.pluck(name)`
* `Object.sameType(x)`
* `Object.same()`
* `Object.toDescriptor()`
* `Object.toDescriptors()`
* `Object.toString()`

#### Object.plain

Following are about hash'es (simple enumerable key value pairs)

* `Object.plain.clone()`
* `Object.plain.compare(p)`
* `Object.plain.elevate([p])`
* `Object.plain.every(f[, p])`
* `Object.plain.filter(f[, p])`
* `Object.plain.forEach(f[, p])`
* `Object.plain.isEmpty()`
* `Object.plain.isPlainObject()`
* `Object.plain.link(p)`
* `Object.plain.map(f[, p])`
* `Object.plain.merge(p)`
* `Object.plain.pluck(name)`
* `Object.plain.same()`
* `Object.plain.setTrue()`
* `Object.plain.setValue(value)`
* `Object.plain.set()`
* `Object.plain.values()`

#### String

* `String.endsWith(s)`
* `String.format(map)`
* `String.indent()`
* `String.pad(n)`
* `String.repeat(n)`
* `String.startsWith(s)`
* `String.trimLeftStr(s)`
* `String.trimRightStr(s)`

##### Convertion methods:

* `String.convert.dashToCamelCase(str)`

<!-- ## Tests -->

<!-- Before running tests make sure you have node and npm installed and you've run -->
<!-- _make install_ first. -->

<!-- 	$ make test -->

<!-- Tests with coverage report: -->

<!-- 	$ make test-cov -->
