{
  "name": "es5-ext",
  "version": "0.6.3",
  "description": "ECMAScript5 extensions",
  "keywords": [
    "ecmascript",
    "ecmascript5",
    "es5",
    "extensions",
    "addons",
    "extras",
    "javascript"
  ],
  "author": {
    "name": "Mariusz Nowak",
    "email": "medikoo+es5-ext@medikoo.com",
    "url": "http://www.medikoo.com/"
  },
  "main": "lib/index",
  "repository": {
    "type": "git",
    "url": "git://github.com/medikoo/es5-ext.git"
  },
  "bugs": {
    "mail": "medikoo+es5-ext@medikoo.com",
    "url": "https://github.com/medikoo/es5-ext/issues"
  },
  "engines": {
    "node": ">=0.1.103"
  },
  "scripts": {
    "test": "./node_modules/tad/bin/tad lib"
  },
  "devDependencies": {
    "tad": "0.1.x"
  },
  "readme": "# es5-ext - ECMAScript5 extensions\n\nUseful methods, functions and objects that are not part of the standard.  \n\n## Installation\n\nCan be used in any environment that implements EcmaScript 5th edition.  \nMany extensions will also work with ECMAScript 3rd edition, if they're not let [es5-shim](https://github.com/kriskowal/es5-shim) be your aid.\n\nTo use it with node:\n\n\t$ npm install es5-ext\n\nFor browser, you can easily create custom toolset with help of\n[modules-webmake](https://github.com/medikoo/modules-webmake)\n\n## Usage\n\nAll utitlities are written with ES5 conventions in mind. It means we mainly deal\nwith methods (not functions) which can directly be\nassigned to any ES native object's prototype, e.g.:\n\n\tFunction.prototype.curry = require('es5-ext/lib/Function/prototype/curry');\n\tArray.prototype.flatten = require('es5-ext/lib/Array/prototype/flatten');\n\tString.prototype.startsWith = require('es5-ext/lib/String/prototype/starts-with');\n\nHowever __in general extending prototypes of native objects is discouraged__, I'd say __it's ok only if you own the context__ (see [extending-javascript-natives](http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/) for more views on that matter).\n\nSo when you don't want to extend native prototypes,\nyou can use methods as functions:\n\n\tvar util = {};\n\tvar call = Function.prototype.call;\n\n\tutil.curry = call.bind(require('es5-ext/lib/Function/prototype/curry'));\n\tutil.flatten = call.bind(require('es5-ext/lib/Array/prototype/flatten'));\n\tutil.startsWith = call.bind(require('es5-ext/lib/String/prototype/starts-with'));\n\n### API\n\n_Each extension is documented at begin of its source file._\n\n* `assertNotNull(arg)`\n* `getNextIdGenerator([prefix[, postfix]])`\n* `global`\n* `guid()`\n* `isPrimitive(arg)`\n* `reserved`\n* `toObject(arg)`\n\n#### Array\n\n* `Array.generate(length, fill0[, fill1[, ...]])`\n\n#### Array.prototype\n\nSame as with standarized ES methods, following methods are generic and can be\ncalled on any object.\n\n* `Array.prototype.bsearchClosest(compareFn)`\n* `Array.prototype.clear()`\n* `Array.prototype.commonLeft(list0[, list1[, ...]])`\n* `Array.prototype.compact()`\n* `Array.prototype.contains(searchElement)`\n* `Array.prototype.copy()`\n* `Array.prototype.diff(other)`\n* `Array.prototype.exclusion(list0[, list1[, ...]])`\n* `Array.prototype.find(query[, thisArg])`\n* `Array.prototype.first()`\n* `Array.prototype.flatten()`\n* `Array.prototype.forEachRight(cb[, thisArg])`\n* `Array.prototype.group(cb[, thisArg])`\n* `Array.prototype.indexesOf(searchElement[, fromIndex])`\n* `Array.prototype.intersection(list0[, list1[, ...]])`\n* `Array.prototype.peek()`\n* `Array.prototype.remove(value)`\n* `Array.prototype.someRight(cb[, thisArg])`\n* `Array.prototype.someValue(cb[, thisArg])`\n* `Array.prototype.uniq()`\n\n#### Boolean\n\n* `Boolean.isBoolean(arg)`\n\n#### Date\n\n* `Date.getFormat(pattern)`\n* `Date.isDate(arg)`\n\n#### Date.prototype\n\n* `Date.prototype.copy(date)`\n* `Date.prototype.duration(to)`\n* `Date.prototype.floorDay()`\n* `Date.prototype.floorMonth()`\n* `Date.prototype.floorYear()`\n* `Date.prototype.monthDaysCount()`\n\n#### Error\n\n* `Error.isError(arg)`\n\n##### Error.prototype\n\n* `Error.prototype.throw()`\n\n#### Function\n\n* `Function.arguments([arg0[, arg1[, ...]])`\n* `Function.context()`\n* `Function.i(arg)`\n* `Function.insert(name, value)`\n* `Function.invoke(name[, arg0[, arg1[, ...]]])`\n* `Function.isArguments(arg)`\n* `Function.isFunction(arg)`\n* `Function.k(arg)`\n* `Function.memoize(fn[, length[, resolvers]])`\n* `Function.noop()`\n* `Function.pluck(name)`\n* `Function.remove(name)`\n\n#### Function.prototype\n\n* `Function.prototype.aritize(n)`\n* `Function.prototype.chain(fn0[, fn1[, ...]])`\n* `Function.prototype.curry([arg0[, arg1[, ...])`\n* `Function.prototype.flip()`\n* `Function.prototype.hold([n[, arg0[, arg1[, ...]]]])`\n* `Function.prototype.lock([arg0[, arg1[, ...])`\n* `Function.prototype.log(log)`\n* `Function.prototype.match()`\n* `Function.prototype.ncurry([n[, arg0[, arg1[, ...]])`\n* `Function.prototype.not()`\n* `Function.prototype.rcurry([arg0[, arg1[, ...])`\n* `Function.prototype.rncurry([n[, arg0[, arg1[, ...]])`\n* `Function.prototype.s(fn)`\n* `Function.prototype.silent([arg0[, arg1[, ...])`\n\n#### Number\n\n* `Number.getAutoincrement(start, step)`\n* `Number.getPad(length[, precision])`\n* `Number.isNumber(arg)`\n\n#### Number.prototype\n\n* `Number.prototype.isLessOrEqual(n)`\n* `Number.prototype.isLess(n)`\n* `Number.prototype.subtract(n)`\n\n#### Object\n\n* `Object.assertCallable(arg)`\n* `Object.getCompareBy(name)`\n* `Object.getSet(value)`\n* `Object.isCallable(arg)`\n* `Object.isList(arg)`\n* `Object.isObject(arg)`\n* `Object.isPlainObject(arg)`\n\n##### Object.descriptors\n\nShortcuts for building descriptors\n\n* `Object.descriptors.c(valueOrGet[, set])`\n* `Object.descriptors.ce(valueOrGet[, set])`\n* `Object.descriptors.cew(value)`\n* `Object.descriptors.cw(value)`\n* `Object.descriptors.e(valueOrGet[, set])`\n* `Object.descriptors.ew(value)`\n* `Object.descriptors.v(valueOrGet[, set])`\n* `Object.descriptors.w()`\n\n#### Object.prototype\n\n* `Object.bindMethods([p[, q]])`\n* `Object.every(f[, p])`\n* `Object.extend(o)`\n* `Object.invoke(args)`\n* `Object.mapToArray(cb[, scope])`\n* `Object.mergeDeep(o)`\n* `Object.merge(p)`\n* `Object.pluck(name)`\n* `Object.sameType(x)`\n* `Object.same()`\n* `Object.toDescriptor()`\n* `Object.toDescriptors()`\n* `Object.toString()`\n\n#### Object.plain\n\nFollowing are about hash'es (simple enumerable key value pairs)\n\n* `Object.plain.clone()`\n* `Object.plain.compare(p)`\n* `Object.plain.elevate([p])`\n* `Object.plain.every(f[, p])`\n* `Object.plain.filter(f[, p])`\n* `Object.plain.forEach(f[, p])`\n* `Object.plain.isEmpty()`\n* `Object.plain.isPlainObject()`\n* `Object.plain.link(p)`\n* `Object.plain.map(f[, p])`\n* `Object.plain.merge(p)`\n* `Object.plain.pluck(name)`\n* `Object.plain.same()`\n* `Object.plain.setTrue()`\n* `Object.plain.setValue(value)`\n* `Object.plain.set()`\n* `Object.plain.values()`\n\n#### String\n\n* `String.endsWith(s)`\n* `String.format(map)`\n* `String.indent()`\n* `String.pad(n)`\n* `String.repeat(n)`\n* `String.startsWith(s)`\n* `String.trimLeftStr(s)`\n* `String.trimRightStr(s)`\n\n##### Convertion methods:\n\n* `String.convert.dashToCamelCase(str)`\n\n<!-- ## Tests -->\n\n<!-- Before running tests make sure you have node and npm installed and you've run -->\n<!-- _make install_ first. -->\n\n<!-- \t$ make test -->\n\n<!-- Tests with coverage report: -->\n\n<!-- \t$ make test-cov -->\n",
  "_id": "es5-ext@0.6.3",
  "_from": "es5-ext@0.6.x"
}
